## 시간 복잡도
- 최대 n번 탐색 -> $O(n)$
- n의 최댓값은 100,000이므로 충분하다.

## 문제 접근법

- 정렬을 이용하면 안되기 때문에, min(A, B)의 값을 정확히 알기 힘들다.  
따라서, A와 B 사이의 개발자 수에 따라 탐색한다.
- A와 B사이의 개발자 수는 늘이거나 줄일 수 있는데, 양 끝에서부터 점점 줄이는 방법으로 투포인터를 사용한다.

1. 양 끝 점을 초기 투 포인터로 잡는다.  
2. 투포인터로 두 점을 양 끝부터 하나씩 줄이며 탐색한다.  
    2-1. 능력치의 최댓값을 계속 확인하며 갱신한다.  
    2-2. 두 점 중, 더 작은 수가 왼쪽이면 왼쪽 점을 오른쪽으로 이동하고 오른쪽이면 오른쪽 점을 왼쪽으로 이동한다.


## 코드

```python
# BOJ
# G4 - 22945(팀 빌딩)

n = int(input())
members = list(map(int, input().split()))
l, r = 0, n - 1
ans = 0

while l < r:
    ans = max(ans, min(members[l], members[r]) * (r - l - 1))
    if members[l] < members[r]:
        l += 1
    else:
        r -= 1

print(ans)
```