## 시간 복잡도
- n만큼 정렬 -> $O(n \log n)$
- 정렬을 제외한 반복이나 sum, 슬라이싱의 경우는 최대 n번 반복이다.
- n의 최대값은 10,000이기 때문에 시간은 충분하다.

## 문제 접근법

1. 센서의 위치를 오름차순 정렬한다.
2. 각 센서 사이의 거리를 구한 후 오름차순 정렬한다.
3. 센서 사이의 거리 중 가장 큰 거리부터 k - 1개를 제외한 거리의 합을 구한다.

- 센서가 1, 6, 9, 3, 6, 7인 경우
- 정렬을 하면 1, 3, 6, 6, 7, 9
- 센서 사이의 거리는 2, 3, 0, 1, 2
- 정렬을 하면 0, 1, 2, 2, 3
- 가장 효율적인 2개의 집중국으로 나누면 [1, 3], [6, 6, 7, 9]가 되는데,  
이 이유는 좌표 3, 6에 있는 두 센서가 가장 멀리 떨어져 있기 때문이다.  
이는 센서 사이의 거리 중 가장 거리가 먼 3을 두 집중국 사이라고 가정한다.
- k - 1개의 뒷부분(집중국 사이)을 제거하고 더하면 된다.  
e.g. 0, 1, 2, 2, 3에서 k - 1인 1개의 뒷부분을 제거하면 0 + 1 + 2 + 2 = 5가 된다.

- k가 3인 경우, [1], [3], [6, 6, 7, 9] 또는 [1, 3], [6, 6, 7], [9] 처럼 정렬된 센서의 거리 중 가장 큰 두 수인 2와 3을 뺀 나머지를 묶어 3개의 집중국으로 나타낼 수 있다.  
=> 0 + 1 + 2 = 3

## 코드

```python
# BOJ
# G5 - 2212(센서)

import sys
input = sys.stdin.readline

n = int(input())
k = int(input())
sensor = sorted(map(int, input().split()))
dist = sorted([sensor[i] - sensor[i - 1] for i in range(1, n)])

print(sum(dist[:n - k]))
```