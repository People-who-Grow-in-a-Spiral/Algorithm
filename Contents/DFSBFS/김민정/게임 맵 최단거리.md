## 시간 복잡도
 

## 문제 접근법
# 풀이
일단, 동서남북 방향으로 이동할 수 있다는 말을 보자마자 떠올린건   
dx방향일시 :[-1,1,0,0]   
dy방향일시 :[1,-1,0,0]   
+bfs(dfs)를 사용해볼 수 있겠다 생각함.
   
일단은 최단거리니까 bfs를 사용해야할것같아서 bfs로 생각하고 알고리즘 짬.

### 큐 사용할건데, 큐에 새로 방문할 노드를 추가할 조건 선정함
1. 벽에 막히면 안됨
2. 맵을 벗어나면 안됨 : 방문할 노드의 위치가 0보다 크고, n or m보다 작아야함
3. 방문헀던 곳이면 안됨 : 이 경우 처음에 단순히 visited 배열만들어서 방문표시 1로 하려했는데.. 문제 리턴값은 마지막에 지나온 거리의 수를 리턴해야하는거라 방문할 때마다 지나온 거리를 업데이트해야한다는것을 알게됨. 따라서 단순 방문처리 배열이 아닌 거리 배열을 만들어야함

### 변수 초기화
- dis(거리배열) : 모두 1로 초기화
- dx, dy : 동서남북으로 이동하기 위한 변수. dx는 좌우, dy는 상하
- que : 방문할 노드를 추가할 저장소, 방문할때마다 popleft

- xx : que에서 노드를 빼고 난 뒤 다음에 방문할 후보의 x위치
- yy : que에서 노드를 뺴고 난 뒤 다음에 방문할 후보의 y위치

### 알고리즘
처음에 큐 만들고, 시작위치 큐에 집어넣고 while문 시작.

큐가 빌때까지 반복:
    pop = 큐의 맨 앞에서 하나 뺌.
    
    dx,dy 반복 :
        xx = 방문 후보 위치의 x값
        yy = 방문 후보 위치의 y값

        만약 방문 후보의 위치가 1.벽에 막히지 않고, 2. 맵을 벗어나지 않고, 3. 거리배열이 1이라면(1이면 방문한적이 없다는 뜻,왜냐면 방문했다면 그 전까지의 거리가 합해졌을테니까) 의 조건을 만족한다면:
            일단 거리 업데이트. 방문 후보의 위치 거리배열에 전 노드의 거리 배열의 숫자를 더해줌.
            큐에 방문 후보의 위치 추가

--여기까지 bfs 탐색 끝. 탐색 후엔 dis 배열에 각 위치의 가중치가 들어가있음.   
만약 dis[n-1][m-1]가 1이라면 방문하지 못한 것이므로 -1 리턴, 1이 아니면 종점의 거리가 들어가있을것이므로 해당값 리턴.

종료


## 코드

```python
from collections import deque

def solution(maps):
    n = len(maps)
    m = len(maps[0])
    dis = [[1]*m for _ in range(n)]
    dx = [-1,1,0,0]
    dy = [0,0,-1,1]
    que = deque()
    que.append((0,0))


    while que:
        pop = que.popleft()

        for x,y in zip(dx,dy): 
            xx = pop[0]+x
            yy = pop[1]+y

            if 0<=xx<n and 0<=yy<m and maps[xx][yy]==1 and dis[xx][yy] == 1:
                dis[xx][yy] += dis[pop[0]][pop[1]]
                que.append((xx,yy))
                
    return -1 if dis[n-1][m-1] == 1 else dis[n-1][m-1]

```