## 시간 복잡도
- n번 순회 * n번 순회 * 최대 n번 순회 -> $O(n^3)$
- n의 최대값이 600이므로 충분하다.

## 문제 접근법

- 구글링을 통해 풀이 방법 확인 -> 두 점을 고정시키고, 나머지 두 점을 투포인터를 이용하여 탐색한다.

1. 입력 받은 눈덩이들을 정렬한다.
2. 고정시킬 두 눈덩이를 2중 반복문을 통해 정해준다.  
고정될 i와 j는 사이에 최소 눈덩이 두 개를 골라야 하기 때문에 3칸 이상 떨어져 있어야 한다.
3. 고정된 두 눈덩이로 첫 번째 눈사람의 크기를 저장한다.
4. 고정된 두 눈덩이 사이의 눈덩이들을 투포인터를 통해 탐색한다.  
4-1. 새로운 두 눈덩이를 고른 후, 두 번째 눈사람의 크기를 저장한다.  
4-2. 두 눈사람 크기의 차를 절대값으로 하여 최소값을 저장한다.  
4-3. 크기의 차가 0이라면 0을 출력하고 즉시 종료한다.  
(차이가 0 미만이 될 수 없기 때문)  
4-4. 첫 번째 눈사람이 더 크다면, 두 번째 눈사람의 왼쪽 눈덩이 인덱스를 증가시킨다.  
(눈덩이가 정렬되어 있기 때문에 두 번째 눈사람의 크기를 키워 첫 번째 눈사람의 크기에 가깝게 만든다.)  
4-5. 두 번째 눈사람이 더 크다면, 두 번째 눈사람의 오른쪽 눈덩이 인덱스를 감소시킨다.  
(두 번째 눈사람의 크기를 줄여 첫 번째 눈사람의 크기에 가깝게 만든다.)


## 코드

```python
# BOJ
# G3 - 20366(같이 눈사람 만들래?)

import sys
input = sys.stdin.readline

n = int(input())
snow = sorted(list(map(int, input().split())))
ans = sys.maxsize

for i in range(n):
    for j in range(i + 3, n):
        snowman_1 = snow[i] + snow[j]
        l, r = i + 1, j - 1

        while l < r:
            snowman_2 = snow[l] + snow[r]
            ans = min(ans, abs(snowman_1 - snowman_2))

            if snowman_1 == snowman_2:
                print(0)
                exit()
            if snowman_2 < snowman_1:
                l += 1
            else:
                r -= 1

print(ans)
```
